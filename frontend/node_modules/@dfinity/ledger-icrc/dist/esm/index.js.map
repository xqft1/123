{
  "version": 3,
  "sources": ["../../src/types/ledger.responses.ts", "../../src/utils/ledger.utils.ts", "../../src/utils/payment.utils.ts"],
  "sourcesContent": ["import type { Principal } from \"@dfinity/principal\";\nimport type { Subaccount, Value } from \"../../candid/icrc_ledger\";\n\n// Source: https://github.com/dfinity/icrc-1#standard-metadata-entries\nexport enum IcrcMetadataResponseEntries {\n  SYMBOL = \"icrc1:symbol\",\n  NAME = \"icrc1:name\",\n  DECIMALS = \"icrc1:decimals\",\n  FEE = \"icrc1:fee\",\n  LOGO = \"icrc1:logo\",\n}\n\nexport type IcrcTokenMetadataResponse = [\n  string | IcrcMetadataResponseEntries,\n  Value,\n][];\n\nexport interface IcrcAccount {\n  owner: Principal;\n  subaccount?: Subaccount;\n}\n\nexport interface IcrcTokenMetadata {\n  name: string;\n  symbol: string;\n  fee: bigint;\n  decimals: number;\n  icon?: string;\n}\n", "import { Principal } from \"@dfinity/principal\";\nimport {\n  bigEndianCrc32,\n  encodeBase32,\n  hexStringToUint8Array,\n  isNullish,\n  nonNullish,\n  notEmptyString,\n  uint8ArrayToHexString,\n} from \"@dfinity/utils\";\nimport {\n  IcrcMetadataResponseEntries,\n  type IcrcAccount,\n  type IcrcTokenMetadata,\n  type IcrcTokenMetadataResponse,\n} from \"../types/ledger.responses\";\n\nconst MAX_SUBACCOUNT_HEX_LENGTH = 64;\n\n/**\n * Encodes an Icrc-1 account compatible into a string.\n * Formatting Reference: https://github.com/dfinity/ICRC-1/blob/main/standards/ICRC-1/TextualEncoding.md\n *\n * @param account { owner: Principal, subaccount?: Uint8Array }\n * @returns string\n */\nexport const encodeIcrcAccount = ({\n  owner,\n  subaccount,\n}: IcrcAccount): string => {\n  if (isNullish(subaccount)) {\n    return owner.toText();\n  }\n\n  const removeLeadingZeros = (text: string): string => text.replace(/^0+/, \"\");\n\n  const subaccountText = removeLeadingZeros(\n    uint8ArrayToHexString(Uint8Array.from(subaccount)),\n  );\n\n  if (subaccountText.length === 0) {\n    return owner.toText();\n  }\n\n  return `${owner.toText()}-${encodeCrc({\n    owner,\n    subaccount,\n  })}.${subaccountText}`;\n};\n\nconst encodeCrc = ({ owner, subaccount }: Required<IcrcAccount>): string => {\n  const crc = bigEndianCrc32(\n    Uint8Array.from([...owner.toUint8Array(), ...subaccount]),\n  );\n\n  return encodeBase32(crc);\n};\n\n/**\n * Decodes a string into an Icrc-1 compatible account.\n * Formatting Reference: https://github.com/dfinity/ICRC-1/blob/main/standards/ICRC-1/TextualEncoding.md\n *\n * @param accountString string\n * @throws Error if the string is not a valid Icrc-1 account\n * @returns IcrcAccount { owner: Principal, subaccount?: Uint8Array }\n */\nexport const decodeIcrcAccount = (accountString: string): IcrcAccount => {\n  const [principalAndMaybeCheckSum, subaccountHex, ...unexpected] =\n    accountString.split(\".\");\n\n  if (!notEmptyString(principalAndMaybeCheckSum)) {\n    throw new Error(\"Invalid account. No string provided.\");\n  }\n\n  if (unexpected.length > 0) {\n    throw new Error(\n      \"Invalid account string format. Expected at most one '.' separator.\",\n    );\n  }\n\n  if (isNullish(subaccountHex)) {\n    return {\n      owner: Principal.fromText(accountString),\n    };\n  }\n\n  const [checksum, ...rest] = principalAndMaybeCheckSum.split(\"-\").reverse();\n  const principalText = rest.reverse().join(\"-\");\n\n  const account = {\n    owner: Principal.fromText(principalText),\n    subaccount: hexStringToUint8Array(\n      subaccountHex.padStart(MAX_SUBACCOUNT_HEX_LENGTH, \"0\"),\n    ),\n  };\n\n  const crcText = encodeCrc(account);\n\n  if (crcText !== checksum) {\n    throw new Error(\"Invalid account. Invalid checksum.\");\n  }\n\n  return account;\n};\n\n/**\n * Maps the token metadata information from a ledger response into a structured record.\n *\n * This utility processes an array of metadata key-value pairs provided by the ledger\n * and extracts specific fields, such as symbol, name, fee, decimals, and logo. It then\n * constructs a `IcrcTokenMetadata` record. If any required fields are missing,\n * the function returns `undefined`.\n *\n * @param {IcrcTokenMetadataResponse} response - An array of key-value pairs representing token metadata.\n *\n * @returns {IcrcTokenMetadata | undefined} - A structured metadata record or `undefined` if required fields are missing.\n */\nexport const mapTokenMetadata = (\n  response: IcrcTokenMetadataResponse,\n): IcrcTokenMetadata | undefined => {\n  const nullishToken = response.reduce<Partial<IcrcTokenMetadata>>(\n    (acc, [key, value]) => {\n      switch (key) {\n        case IcrcMetadataResponseEntries.SYMBOL:\n          acc = { ...acc, ...(\"Text\" in value && { symbol: value.Text }) };\n          break;\n        case IcrcMetadataResponseEntries.NAME:\n          acc = { ...acc, ...(\"Text\" in value && { name: value.Text }) };\n          break;\n        case IcrcMetadataResponseEntries.FEE:\n          acc = { ...acc, ...(\"Nat\" in value && { fee: value.Nat }) };\n          break;\n        case IcrcMetadataResponseEntries.DECIMALS:\n          acc = {\n            ...acc,\n            ...(\"Nat\" in value && { decimals: Number(value.Nat) }),\n          };\n          break;\n        case IcrcMetadataResponseEntries.LOGO:\n          acc = { ...acc, ...(\"Text\" in value && { icon: value.Text }) };\n      }\n\n      return acc;\n    },\n    {},\n  );\n\n  const isIcrcTokenMetadata = (\n    arg: Partial<IcrcTokenMetadata>,\n  ): arg is IcrcTokenMetadata =>\n    nonNullish(arg.symbol) &&\n    nonNullish(arg.name) &&\n    nonNullish(arg.fee) &&\n    nonNullish(arg.decimals);\n\n  if (!isIcrcTokenMetadata(nullishToken)) {\n    return undefined;\n  }\n\n  return nullishToken;\n};\n", "import { isNullish, nonNullish } from \"@dfinity/utils\";\n\n/**\n * \uD83D\uDC40 This feature is currently in draft. You can find more information about it at https://github.com/dfinity/ICRC/issues/22.\n *\n * A naive implementation of a payment parser. Given a code, the function attempts to extract a token name, account identifier (textual representation), and an optional amount.\n *\n * If the code doesn't match the expected pattern, `undefined` is returned for simplicity.\n * Similarly, if an optional amount is provided but it's not a valid number, the parser will not throw an exception and returns `undefined`.\n *\n * Please note that this function doesn't perform any validity checks on the extracted information.\n * It does not verify if the token is known or if the identifier is a valid address.\n *\n * ```\n * urn            = token \":\" address [ \"?\" params]\n * token         = [ ckbtc / icp / chat / bitcoin / ethereum ... ]\n * address       = STRING\n * params        = param [ \"&\" params ]\n * param         = [ amountparam ]\n * amountparam   = \"amount=\" *digit [ \".\" *digit ]\n * ```\n *\n * @param code string\n * @returns { token: string; identifier: string; amount?: number } | undefined\n */\nexport const decodePayment = (\n  code: string,\n): { token: string; identifier: string; amount?: number } | undefined => {\n  const regex =\n    /^([a-zA-Z]+):([A-Za-z0-9:\\-.]+).*?(?:[?&](?:amount|value)=(\\d+(?:\\.\\d+)?))?$/;\n\n  const match = code.match(regex);\n  if (isNullish(match)) {\n    return undefined;\n  }\n\n  const [_, token, identifier, amount] = match;\n\n  return {\n    token,\n    identifier,\n    ...(nonNullish(amount) &&\n      !isNaN(parseFloat(amount)) && { amount: parseFloat(amount) }),\n  };\n};\n"],
  "mappings": "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",
  "names": ["IcrcMetadataResponseEntries", "Principal", "bigEndianCrc32", "encodeBase32", "hexStringToUint8Array", "isNullish", "nonNullish", "notEmptyString", "uint8ArrayToHexString", "MAX_SUBACCOUNT_HEX_LENGTH", "encodeIcrcAccount", "owner", "subaccount", "isNullish", "subaccountText", "text", "uint8ArrayToHexString", "encodeCrc", "crc", "bigEndianCrc32", "encodeBase32", "decodeIcrcAccount", "accountString", "principalAndMaybeCheckSum", "subaccountHex", "unexpected", "notEmptyString", "Principal", "checksum", "rest", "principalText", "account", "hexStringToUint8Array", "mapTokenMetadata", "response", "nullishToken", "acc", "key", "value", "arg", "nonNullish", "isNullish", "nonNullish", "decodePayment", "code", "regex", "match", "_", "token", "identifier", "amount"]
}
